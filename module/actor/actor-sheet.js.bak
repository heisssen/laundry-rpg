import { rollDice } from "../dice.js";
import { LaundryCharacterBuilder, applyAssignmentToActor } from "./character-builder.js";
import { openSupportRequestApp } from "../apps/support-request.js";
import { openEndeavoursApp } from "../apps/endeavours.js";
import {
    KPI_HORIZONS,
    KPI_PRIORITIES,
    KPI_STATUSES,
    closeKpiAtIndex,
    createNewKpi,
    normalizeKpiEntries,
    summarizeKpiEntries
} from "../utils/kpi.js";
import {
    describeTalentPrerequisiteResult,
    evaluateTalentPrerequisites
} from "../utils/talent-prerequisites.js";
import {
    NPC_PRESETS,
    applyNpcPreset,
    normalizeNpcQuickAction
} from "../utils/npc-presets.js";

const KPI_STATUS_CSS = {
    open: "kpi-open",
    completed: "kpi-completed",
    failed: "kpi-failed"
};

export class LaundryActorSheet extends ActorSheet {

    /** @override */
    static get defaultOptions() {
        return foundry.utils.mergeObject(super.defaultOptions, {
            classes: ["laundry-rpg", "sheet", "actor"],
            template: "systems/laundry-rpg/templates/actor/actor-sheet.html",
            width: 720,
            height: 720,
            tabs: [{ navSelector: ".sheet-tabs", contentSelector: ".sheet-body", initial: "dossier" }],
            dragDrop: [{ dragSelector: ".item-list .item", dropSelector: null }]
        });
    }

    /** @override */
    getData() {
        const context = super.getData();
        const actorData = context.actor?.system ?? {};
        const items = Array.isArray(context.items)
            ? context.items
            : this.actor.items.contents.map(i => i.toObject());

        context.system = actorData;
        context.flags  = context.actor.flags;

        // Pass system config to templates (used by {{selectOptions}})
        context.config = CONFIG.LAUNDRY;

        // Sort items by type for convenience
        context.skills     = items.filter(i => i.type === "skill");
        context.talents    = items
            .filter(i => i.type === "talent")
            .map(item => {
                const prereq = evaluateTalentPrerequisites(this.actor, item);
                const status = prereq.status;
                const statusLabel = status === "unmet"
                    ? game.i18n.localize("LAUNDRY.PrereqUnmet")
                    : (status === "review"
                        ? game.i18n.localize("LAUNDRY.PrereqReview")
                        : game.i18n.localize("LAUNDRY.PrereqMet"));
                return {
                    ...item,
                    prereqStatus: status,
                    prereqStatusLabel: statusLabel,
                    prereqSummary: describeTalentPrerequisiteResult(prereq),
                    prereqUnmet: prereq.unmet,
                    prereqManual: prereq.manual,
                    prereqCss: `talent-prereq-${status}`
                };
            });
        context.gear       = items
            .filter(i => ["gear", "weapon", "armour"].includes(i.type))
            .sort((a, b) => a.name.localeCompare(b.name));
        context.spells     = items.filter(i => i.type === "spell");
        context.weapons    = items.filter(i => i.type === "weapon");
        context.armour     = items.filter(i => i.type === "armour");
        context.miscGear   = items.filter(i => i.type === "gear");
        const normalizedKpi = normalizeKpiEntries(actorData.kpi);
        const kpiSummary = summarizeKpiEntries(normalizedKpi);
        const kpiCanEdit = Boolean(this.actor.isOwner || game.user?.isGM);
        const kpiCanClose = Boolean(game.user?.isGM);
        const kpiCanDelete = Boolean(game.user?.isGM);
        const kpiCanAdd = Boolean(this.actor.isOwner || game.user?.isGM);
        context.kpiSummary = kpiSummary;
        context.kpiPermissions = {
            canEdit: kpiCanEdit,
            canClose: kpiCanClose,
            canDelete: kpiCanDelete,
            canAdd: kpiCanAdd
        };
        context.kpiOptions = {
            horizons: KPI_HORIZONS.map(option => ({
                key: option.key,
                label: game.i18n.localize(option.labelKey)
            })),
            priorities: KPI_PRIORITIES.map(option => ({
                key: option.key,
                label: game.i18n.localize(option.labelKey)
            })),
            statuses: KPI_STATUSES.map(option => ({
                key: option.key,
                label: game.i18n.localize(option.labelKey)
            }))
        };
        context.kpiGroups = KPI_HORIZONS.map(group => {
            const groupEntries = normalizedKpi
                .filter(entry => entry.horizon === group.key)
                .map(entry => {
                    const archived = entry.status !== "open";
                    return {
                        ...entry,
                        archived,
                        statusCss: KPI_STATUS_CSS[entry.status] ?? "kpi-open",
                        resolved: archived,
                        canClose: kpiCanClose && entry.status === "open",
                        closedDateLabel: entry.closedAt ? new Date(entry.closedAt).toLocaleDateString() : "",
                        rewardLabel: entry.rewardedXp > 0 ? `+${entry.rewardedXp} XP` : "No XP"
                    };
                });
            const openEntries = groupEntries.filter(entry => !entry.archived);
            const archivedEntries = groupEntries.filter(entry => entry.archived);
            const showArchived = this._isKpiArchiveVisible(group.key);
            return {
                key: group.key,
                label: game.i18n.localize(group.labelKey),
                entries: [...openEntries, ...archivedEntries],
                openCount: openEntries.length,
                archivedCount: archivedEntries.length,
                showArchived
            };
        });

        const skillItemsByName = new Map(context.skills.map(s => [s.name, s]));
        const skillDefs = CONFIG.LAUNDRY.skills ?? [];
        context.skillRows = skillDefs.map(def => {
            const item = skillItemsByName.get(def.name);
            const attribute = item?.system?.attribute ?? def.attribute ?? "mind";
            const attrValue = actorData.attributes?.[attribute]?.value ?? 1;
            const training = item?.system?.training ?? 0;
            const focus = item?.system?.focus ?? 0;
            return {
                name: def.name,
                itemId: item?._id ?? null,
                img: item?.img ?? "systems/laundry-rpg/icons/generated/_defaults/skill.webp",
                attribute,
                attributeLabel: CONFIG.LAUNDRY.attributes?.[attribute]?.label ?? attribute,
                attrValue,
                training,
                focus,
                level: attrValue + training,
                trained: training > 0
            };
        });
        context.upgradeShop = {
            enabled: context.actor.type === "character" && (this.actor.isOwner || game.user?.isGM),
            unspentXp: Math.max(0, Math.trunc(Number(actorData.details?.xp?.unspent) || 0)),
            skills: context.skillRows
                .map(row => ({ name: row.name, training: row.training, focus: row.focus }))
                .sort((a, b) => a.name.localeCompare(b.name)),
            attributes: [
                { id: "body", label: game.i18n.localize("LAUNDRY.Body"), value: Math.max(1, Math.trunc(Number(actorData.attributes?.body?.value) || 1)) },
                { id: "mind", label: game.i18n.localize("LAUNDRY.Mind"), value: Math.max(1, Math.trunc(Number(actorData.attributes?.mind?.value) || 1)) },
                { id: "spirit", label: game.i18n.localize("LAUNDRY.Spirit"), value: Math.max(1, Math.trunc(Number(actorData.attributes?.spirit?.value) || 1)) }
            ]
        };

        // The Ladder combat ratings now come from Actor derived data.
        context.ladder = {
            melee: actorData.derived?.melee?.label ?? "Poor",
            accuracy: actorData.derived?.accuracy?.label ?? "Poor",
            defence: actorData.derived?.defence?.label ?? "Poor"
        };

        // NPC-only extras
        context.isNpc       = context.actor.type === "npc";
        context.isCharacter = context.actor.type === "character";
        context.hasAssignment = !!actorData.details?.assignment;
        const npcRaw = actorData.npc ?? {};
        const npcClass = String(npcRaw.class ?? "elite");
        const npcMode = String(npcRaw.mode ?? "lite");
        const npcFastDamage = Boolean(npcRaw.fastDamage ?? true);
        const npcTrackInjuries = Boolean(npcRaw.trackInjuries ?? false);
        const npcMobSize = Math.max(1, Math.trunc(Number(npcRaw.mobSize) || 1));
        const npcDefeated = Boolean(npcRaw.defeated) || Math.max(0, Math.trunc(Number(actorData.derived?.toughness?.value) || 0)) <= 0;
        const flaggedNpcQuickActions = this.actor.getFlag?.("laundry-rpg", "npcQuickActions");
        const npcQuickActionSource = Array.isArray(npcRaw.quickActions) && npcRaw.quickActions.length
            ? npcRaw.quickActions
            : (Array.isArray(flaggedNpcQuickActions) ? flaggedNpcQuickActions : []);
        const generatedNpcQuickActions = this._buildNpcSuggestedQuickActions();
        const npcQuickActionSeed = npcQuickActionSource.length
            ? npcQuickActionSource
            : generatedNpcQuickActions;
        const npcQuickActions = npcQuickActionSeed
            .map(entry => normalizeNpcQuickAction(entry))
            .map((entry, index, allActions) => ({
                ...entry,
                index,
                canMoveUp: index > 0,
                canMoveDown: index < allActions.length - 1
            }));
        const npcCanSpawn = Boolean(game.user?.isGM && canvas?.scene);

        const activeCombatant = game.combat?.combatant ?? null;
        const isActorTurn = Boolean(activeCombatant?.actor?.id === this.actor.id);
        const turnEconomy = game.laundry?.getCombatTurnEconomy?.(this.actor) ?? {
            tracked: false,
            isActorTurn: false,
            actionsRemaining: 0,
            moveRemaining: 0
        };
        const statusIds = Object.keys(game.laundry?.conditions ?? {
            blinded: true,
            prone: true,
            stunned: true,
            weakened: true
        });
        const actorStatusSet = this._getActorStatusSet();
        const conditionConfigs = statusIds.map(id => this._getConditionConfig(id));
        const activeConditions = conditionConfigs.filter(entry => actorStatusSet.has(entry.id));
        const equippedWeapons = context.weapons
            .filter(item => item.system?.equipped === true)
            .sort((a, b) => a.name.localeCompare(b.name));
        const equippedArmour = context.armour
            .filter(item => item.system?.equipped === true)
            .sort((a, b) => a.name.localeCompare(b.name));

        context.combatSnapshot = {
            toughness: {
                value: Math.max(0, Math.trunc(Number(actorData.derived?.toughness?.value) || 0)),
                max: Math.max(0, Math.trunc(Number(actorData.derived?.toughness?.max) || 0))
            },
            adrenaline: {
                value: Math.max(0, Math.trunc(Number(actorData.derived?.adrenaline?.value) || 0)),
                max: Math.max(0, Math.trunc(Number(actorData.derived?.adrenaline?.max) || 0))
            },
            armour: Math.max(0, Math.trunc(Number(actorData.derived?.armour?.value) || 0)),
            initiative: Math.max(0, Math.trunc(Number(actorData.derived?.initiative?.value) || 0)),
            awareness: Math.max(0, Math.trunc(Number(actorData.derived?.naturalAwareness?.value) || 0)),
            melee: {
                value: Math.max(0, Math.trunc(Number(actorData.derived?.melee?.value) || 0)),
                label: actorData.derived?.melee?.label ?? "Poor"
            },
            accuracy: {
                value: Math.max(0, Math.trunc(Number(actorData.derived?.accuracy?.value) || 0)),
                label: actorData.derived?.accuracy?.label ?? "Poor"
            },
            defence: {
                value: Math.max(0, Math.trunc(Number(actorData.derived?.defence?.value) || 0)),
                label: actorData.derived?.defence?.label ?? "Poor"
            }
        };
        context.combatSkills = ["Close Combat", "Ranged", "Reflexes", "Fortitude", "Awareness", "Magic"]
            .map(name => context.skillRows.find(skill => skill.name === name))
            .filter(Boolean);
        context.combatConditions = conditionConfigs.map(entry => ({
            ...entry,
            active: actorStatusSet.has(entry.id)
        }));
        context.combatLoadout = {
            weapons: equippedWeapons,
            armour: equippedArmour
        };
        context.combat = {
            isActorTurn,
            canEndTurn: isActorTurn && Boolean(game.user?.isGM || activeCombatant?.actor?.isOwner),
            hasActiveConditions: activeConditions.length > 0,
            conditionSummary: activeConditions.length
                ? activeConditions.map(entry => entry.name).join(", ")
                : "No active conditions.",
            hasLoadout: equippedWeapons.length > 0 || equippedArmour.length > 0,
            turnEconomy,
            canTrackTurnEconomy: Boolean(turnEconomy.tracked),
            canManageTurnEconomy: Boolean(turnEconomy.tracked && turnEconomy.isActorTurn && (game.user?.isGM || this.actor.isOwner)),
            canOpenGmTracker: Boolean(game.user?.isGM && game.laundry?.openGMTracker),
            gmTrackerHint: "GM monitoring: Threat, Team Luck, BAU prompts and party overview are in GM Tracker."
        };
        context.npcOps = {
            mode: npcMode,
            npcClass,
            mobSize: npcMobSize,
            fastDamage: npcFastDamage,
            trackInjuries: npcTrackInjuries,
            defeated: npcDefeated,
            archetype: String(npcRaw.archetype ?? ""),
            quickActions: npcQuickActions,
            presets: NPC_PRESETS.map(entry => ({
                id: entry.id,
                name: entry.name
            })),
            actionKinds: [
                { id: "attack", name: "Attack" },
                { id: "spell", name: "Spell" },
                { id: "test", name: "Test" }
            ],
            usingSuggestedActions: !npcQuickActionSource.length && npcQuickActions.length > 0,
            canSpawnToScene: npcCanSpawn
        };

        return context;
    }

    // ─── Ladder helpers ───────────────────────────────────────────────────────

    _getSkillTraining(items, skillName) {
        if (!items) return 0;
        const skill = items.find(i => i.type === "skill" && i.name === skillName);
        return skill ? (skill.system.training ?? 0) : 0;
    }

    _getLadderRating(attribute, training) {
        const total   = (attribute ?? 1) + (training ?? 0);
        const ladder  = CONFIG.LAUNDRY.ladder;
        const matched = ladder.find(entry => total >= entry.min);
        return matched ? matched.label : "Poor";
    }

    _getActorStatusSet() {
        const statuses = new Set();
        for (const effect of this.actor.effects ?? []) {
            const effectStatuses = effect?.statuses instanceof Set
                ? Array.from(effect.statuses)
                : Array.isArray(effect?.statuses)
                    ? effect.statuses
                    : [];
            for (const statusId of effectStatuses) {
                if (statusId) statuses.add(String(statusId));
            }
            const legacyStatus = effect.getFlag?.("core", "statusId");
            if (legacyStatus) statuses.add(String(legacyStatus));
        }
        return statuses;
    }

    _getConditionConfig(statusId) {
        const entry = (CONFIG.statusEffects ?? []).find(effect => effect.id === statusId);
        return {
            id: statusId,
            name: entry?.name ?? statusId,
            img: entry?.img ?? "systems/laundry-rpg/icons/generated/_defaults/talent.webp"
        };
    }

    // ─── Listeners ────────────────────────────────────────────────────────────

    /** @override */
    activateListeners(html) {
        super.activateListeners(html);

        html.find(".call-support").click(this._onCallSupport.bind(this));
        html.find(".open-endeavours").click(this._onOpenEndeavours.bind(this));
        html.find(".take-downtime").click(this._onOpenEndeavours.bind(this));
        html.on("click", ".npc-import-world", (ev) => this._onNpcImportWorld(ev));
        html.on("click", ".npc-preset-apply", (ev) => this._onNpcPresetApply(ev));
        html.on("click", ".npc-action-add", (ev) => this._onNpcActionAdd(ev));
        html.on("click", ".npc-action-autofill", (ev) => this._onNpcActionAutofill(ev));
        html.on("click", ".npc-action-delete", (ev) => this._onNpcActionDelete(ev));
        html.on("click", ".npc-action-duplicate", (ev) => this._onNpcActionDuplicate(ev));
        html.on("click", ".npc-action-move", (ev) => this._onNpcActionMove(ev));
        html.on("click", ".npc-action-roll", (ev) => this._onNpcActionRoll(ev));
        html.on("click", ".npc-reset-defeated", (ev) => this._onNpcResetDefeated(ev));
        html.on("change", ".npc-action-field", (ev) => this._onNpcActionFieldChange(ev));

        // Render only for owners
        if (!this.isEditable) return;

        // Item creation
        html.find(".item-create").click(this._onItemCreate.bind(this));
        html.find(".skill-adjust").click(this._onSkillAdjust.bind(this));
        html.find(".skill-attr").change(this._onSkillAttributeChange.bind(this));
        html.find(".inv-tab").click(this._onInventoryTab.bind(this));
        html.find(".inv-search").on("input", this._onInventorySearch.bind(this));
        html.find(".init-agent").click(this._onInitAgent.bind(this));
        html.find(".end-turn").click(this._onEndTurn.bind(this));
        html.find(".combat-roll-initiative").click(this._onCombatRollInitiative.bind(this));
        html.find(".combat-status-toggle").click(this._onCombatStatusToggle.bind(this));
        html.find(".combat-open-gm-tracker").click(this._onCombatOpenGmTracker.bind(this));
        html.find(".combat-use-action").click(this._onCombatUseAction.bind(this));
        html.find(".combat-use-move").click(this._onCombatUseMove.bind(this));
        html.find(".combat-adrenaline-action").click(this._onCombatAdrenalineAction.bind(this));
        html.find(".take-breather").click(this._onTakeBreather.bind(this));
        html.find(".standard-rest").click(this._onStandardRest.bind(this));
        html.find(".bio-autofill").click(this._onBioAutofill.bind(this));
        html.find(".kpi-add").click(this._onKpiAdd.bind(this));
        html.find(".kpi-delete").click(this._onKpiDelete.bind(this));
        html.find(".kpi-close").click(this._onKpiClose.bind(this));
        html.find(".kpi-archive-toggle").click(this._onKpiArchiveToggle.bind(this));
        html.on("change", ".kpi-field", (ev) => this._onKpiFieldChange(ev));
        html.find(".kpi-shop-buy").click(this._onKpiShopBuy.bind(this));
        html.find(".kpi-shop-buy-talent").click(this._onKpiShopBuyTalent.bind(this));

        // Item editing
        html.find(".item-edit").click(ev => {
            const li   = ev.currentTarget.closest(".item");
            const item = this.actor.items.get(li.dataset.itemId);
            item?.sheet.render(true);
        });

        // Item deletion
        html.find(".item-delete").click(async ev => {
            const li   = ev.currentTarget.closest(".item");
            const item = this.actor.items.get(li.dataset.itemId);
            if (!item) return;
            const confirmed = await Dialog.confirm({
                title: game.i18n.localize("LAUNDRY.DeleteItem"),
                content: `<p>${game.i18n.format("LAUNDRY.DeleteItemConfirm", { name: item.name })}</p>`,
                classes: ["laundry-rpg", "laundry-dialog"]
            });
            if (confirmed) {
                await this.actor.deleteEmbeddedDocuments("Item", [li.dataset.itemId]);
                li.remove();
            }
        });

        // Equip toggle (weapons / armour)
        html.find(".item-equip").click(ev => {
            const li   = ev.currentTarget.closest(".item");
            const item = this.actor.items.get(li.dataset.itemId);
            if (!item) return;
            item.update({ "system.equipped": !item.system.equipped });
        });

        // Rollable items and attributes
        html.find(".rollable").click(this._onRoll.bind(this));
    }

    /** @override */
    async _onChangeInput(event) {
        const target = event?.currentTarget ?? event?.target;
        const isXpField = Boolean(target?.classList?.contains("xp-field"));

        if (isXpField && game.user?.isGM && this.actor.type === "character") {
            event?.preventDefault?.();
            await this._onXpFieldChange(event);
            return;
        }

        return super._onChangeInput(event);
    }

    // ─── Item creation ────────────────────────────────────────────────────────

    async _onItemCreate(ev) {
        ev.preventDefault();
        const header = ev.currentTarget;
        const type   = header.dataset.type;
        const name   = `New ${type.charAt(0).toUpperCase() + type.slice(1)}`;
        const data   = foundry.utils.deepClone(header.dataset);
        delete data.type;

        return Item.create({ name, type, system: data }, { parent: this.actor });
    }

    // ─── Rolling ──────────────────────────────────────────────────────────────

    async _onRoll(ev) {
        ev.preventDefault();
        const el      = ev.currentTarget;
        const dataset = el.dataset;

        // Skill / item roll
        if (dataset.rollType === "item") {
            const li   = el.closest(".item");
            const item = this.actor.items.get(li?.dataset.itemId);
            if (item) return item.roll();
            return;
        }

        if (dataset.rollType === "skill") {
            const skillName = dataset.skillName;
            const attribute = dataset.attribute ?? "mind";
            let skillItem = this.actor.items.find(i => i.type === "skill" && i.name === skillName);

            if (!skillItem && this.actor.isOwner) {
                skillItem = await this._getOrCreateSkillItem(skillName, attribute);
            }
            if (skillItem) return skillItem.roll();

            const attrVal = this.actor.system.attributes?.[attribute]?.value ?? 1;
            return rollDice({
                pool: attrVal,
                complexity: 1,
                flavor: `${skillName} (${attribute.charAt(0).toUpperCase() + attribute.slice(1)} ${attrVal})`,
                actorId: this.actor.id,
                rollContext: {
                    sourceType: "skill",
                    sourceName: skillName,
                    skillName,
                    attribute,
                    isMagic: String(skillName ?? "").trim().toLowerCase() === "magic",
                    isSpell: false
                }
            });
        }

        // Attribute roll (data-roll-type="attribute" data-attribute="body")
        if (dataset.rollType === "attribute") {
            const attrName = dataset.attribute;
            const attrVal  = this.actor.system.attributes[attrName]?.value ?? 1;
            return rollDice({
                pool:   attrVal,
                complexity: 1,
                actorId: this.actor.id,
                flavor: game.i18n.format("LAUNDRY.RollingAttribute", {
                    attribute: attrName.charAt(0).toUpperCase() + attrName.slice(1)
                }),
                rollContext: {
                    sourceType: "attribute",
                    sourceName: attrName,
                    attribute: attrName,
                    isMagic: false,
                    isSpell: false
                }
            });
        }
    }

    _onInventoryTab(ev) {
        ev.preventDefault();
        const tab = ev.currentTarget.dataset.invTab ?? "all";
        const tabs = this.element.find(".inv-tab");
        tabs.removeClass("active");
        ev.currentTarget.classList.add("active");
        this._applyInventoryFilters();
    }

    _onInventorySearch(ev) {
        ev.preventDefault();
        this._applyInventoryFilters();
    }

    _applyInventoryFilters() {
        const activeTab = this.element.find(".inv-tab.active").data("invTab") ?? "all";
        const query = (this.element.find(".inv-search").val() ?? "").toString().trim().toLowerCase();
        const rows = this.element.find(".inv-row");
        rows.each((_, row) => {
            row.classList.remove("inv-hidden", "inv-search-hidden");
            const kind = row.dataset.invType ?? "all";
            const name = (row.querySelector(".item-name")?.textContent ?? "").toLowerCase();
            if (activeTab !== "all" && kind !== activeTab) row.classList.add("inv-hidden");
            if (query && !name.includes(query)) row.classList.add("inv-search-hidden");
        });
    }

    async _onSkillAdjust(ev) {
        ev.preventDefault();
        const btn = ev.currentTarget;
        const skillName = btn.dataset.skillName;
        const attribute = btn.dataset.attribute ?? "mind";
        const stat = btn.dataset.stat;
        const delta = Number(btn.dataset.delta ?? 0);
        if (!skillName || !stat || !["training", "focus"].includes(stat) || !delta) return;

        const skill = await this._getOrCreateSkillItem(skillName, attribute);
        const current = Number(skill.system?.[stat] ?? 0);
        const next = Math.max(0, Math.min(6, current + delta));
        if (next === current) return;

        await skill.update({ [`system.${stat}`]: next });
        this.render(false);
    }

    async _onSkillAttributeChange(ev) {
        const select = ev.currentTarget;
        const skillName = select.dataset.skillName;
        const attribute = select.value;
        if (!skillName || !attribute) return;

        const skill = await this._getOrCreateSkillItem(skillName, attribute);
        if ((skill.system?.attribute ?? "mind") === attribute) return;

        await skill.update({ "system.attribute": attribute });
        this.render(false);
    }

    async _getOrCreateSkillItem(skillName, attribute) {
        const existing = this.actor.items.find(i => i.type === "skill" && i.name === skillName);
        if (existing) return existing;

        const created = await this.actor.createEmbeddedDocuments("Item", [{
            name: skillName,
            type: "skill",
            img: "systems/laundry-rpg/icons/generated/_defaults/skill.webp",
            system: {
                attribute,
                training: 0,
                focus: 0,
                description: ""
            }
        }]);
        return created?.[0] ?? this.actor.items.find(i => i.type === "skill" && i.name === skillName);
    }

    async _onInitAgent(ev) {
        ev.preventDefault();
        if (!this.actor.isOwner) return;
        const existing = Object.values(ui.windows).find(app =>
            app instanceof LaundryCharacterBuilder
            && app.actor?.id === this.actor.id
            && app.rendered
        );
        if (existing) {
            existing.bringToTop();
            return;
        }
        const builder = await LaundryCharacterBuilder.create(this.actor);
        builder?.render(true);
    }

    async _onEndTurn(ev) {
        ev.preventDefault();
        const combat = game.combat;
        if (!combat || !combat.combatant) {
            ui.notifications.warn(game.i18n.localize("LAUNDRY.NoActiveCombat"));
            return;
        }

        const activeCombatant = combat.combatant;
        if (activeCombatant.actor?.id !== this.actor.id) {
            ui.notifications.warn(game.i18n.localize("LAUNDRY.NotYourTurn"));
            return;
        }

        const canControl = game.user?.isGM || activeCombatant.actor?.isOwner;
        if (!canControl) {
            ui.notifications.warn(game.i18n.localize("LAUNDRY.NotYourTurn"));
            return;
        }

        await combat.nextTurn();
    }

    async _onCombatRollInitiative(ev) {
        ev.preventDefault();

        let combat = game.combat;
        if (!combat) {
            if (!game.user?.isGM) {
                ui.notifications.warn("Start combat first, or ask the GM to create an encounter.");
                return;
            }

            const sceneId = canvas?.scene?.id ?? null;
            if (!sceneId) {
                ui.notifications.warn("No active scene found for combat.");
                return;
            }
            combat = await Combat.create({ scene: sceneId, active: true });
        }

        let combatant = combat.combatants.find(c => c.actorId === this.actor.id);
        if (!combatant) {
            const token = canvas?.tokens?.placeables?.find(t => t.actor?.id === this.actor.id) ?? null;
            const created = await combat.createEmbeddedDocuments("Combatant", [{
                actorId: this.actor.id,
                tokenId: token?.id ?? null,
                hidden: false
            }]);
            const createdId = created?.[0]?._id ?? created?.[0]?.id ?? null;
            combatant = createdId
                ? combat.combatants.get(createdId)
                : combat.combatants.find(c => c.actorId === this.actor.id);
        }

        if (!combatant) {
            ui.notifications.warn("Failed to create a combatant for this actor.");
            return;
        }

        await combat.rollInitiative([combatant.id]);
        ui.combat?.render(true);
    }

    async _onCombatStatusToggle(ev) {
        ev.preventDefault();
        const statusId = String(ev.currentTarget?.dataset?.statusId ?? "").trim();
        if (!statusId) return;

        const actorStatuses = game.laundry?.getActorStatuses?.(this.actor) ?? new Set();
        if (actorStatuses.has(statusId)) {
            if (statusId === "prone") {
                const spentMove = await game.laundry?.consumeCombatMove?.(this.actor, { warn: true });
                if (spentMove === false) return;
            }
            await game.laundry?.removeCondition?.(this.actor, statusId, { suppressChat: true });
            this.render(false);
            return;
        }

        await game.laundry?.applyCondition?.(this.actor, statusId, {
            durationRounds: 0,
            source: "sheet-toggle",
            suppressChat: true
        });
        this.render(false);
    }

    _onCombatOpenGmTracker(ev) {
        ev.preventDefault();
        if (!game.user?.isGM) return;
        game.laundry?.openGMTracker?.();
    }

    async _onCombatUseAction(ev) {
        ev.preventDefault();
        await game.laundry?.consumeCombatAction?.(this.actor, { warn: true });
    }

    async _onCombatUseMove(ev) {
        ev.preventDefault();
        await game.laundry?.consumeCombatMove?.(this.actor, { warn: true });
    }

    async _onCombatAdrenalineAction(ev) {
        ev.preventDefault();
        await game.laundry?.spendAdrenalineForExtraAction?.(this.actor);
    }

    async _onTakeBreather(ev) {
        ev.preventDefault();
        const adrenalineMax = Math.max(
            0,
            Math.trunc(Number(this.actor.system?.derived?.adrenaline?.max) || 0)
        );
        await this.actor.update({
            "system.derived.adrenaline.value": adrenalineMax
        });
    }

    async _onStandardRest(ev) {
        ev.preventDefault();
        const adrenalineMax = Math.max(
            0,
            Math.trunc(Number(this.actor.system?.derived?.adrenaline?.max) || 0)
        );
        const toughnessMax = Math.max(
            0,
            Math.trunc(Number(this.actor.system?.derived?.toughness?.max) || 0)
        );

        await this.actor.update({
            "system.derived.adrenaline.value": adrenalineMax,
            "system.derived.toughness.value": toughnessMax,
            "system.derived.toughness.damage": 0
        });

        const escapedName = foundry.utils.escapeHTML(this.actor.name ?? "Agent");
        await ChatMessage.create({
            speaker: ChatMessage.getSpeaker({ actor: this.actor }),
            content: `<p><strong>${escapedName}</strong> has completed a Standard Rest and recovered Toughness and Adrenaline.</p>`
        });
    }

    async _onXpFieldChange(ev) {
        if (!game.user?.isGM) return;
        if (this.actor.type !== "character") return;

        const key = String(ev.currentTarget?.dataset?.xpKey ?? "").trim().toLowerCase();
        if (!["value", "unspent"].includes(key)) return;

        const raw = Math.trunc(Number(ev.currentTarget?.value ?? 0));
        const entered = Number.isFinite(raw) ? Math.max(0, raw) : 0;
        const currentTotal = Math.max(0, Math.trunc(Number(this.actor.system?.details?.xp?.value) || 0));
        const currentUnspent = Math.max(0, Math.trunc(Number(this.actor.system?.details?.xp?.unspent) || 0));

        let nextTotal = currentTotal;
        let nextUnspent = currentUnspent;

        if (key === "value") {
            nextTotal = entered;
            const delta = nextTotal - currentTotal;
            nextUnspent = Math.max(0, currentUnspent + delta);
            nextUnspent = Math.min(nextUnspent, nextTotal);
        } else {
            nextUnspent = entered;
            if (nextUnspent > nextTotal) nextTotal = nextUnspent;
        }

        if (nextTotal === currentTotal && nextUnspent === currentUnspent) return;

        await this.actor.update({
            "system.details.xp.value": nextTotal,
            "system.details.xp.unspent": nextUnspent
        });
        this.render(false);
    }

    async _onCallSupport(ev) {
        ev.preventDefault();
        await openSupportRequestApp(this.actor);
    }

    async _onOpenEndeavours(ev) {
        ev.preventDefault();
        await openEndeavoursApp(this.actor);
    }

    async _onNpcImportWorld(ev) {
        ev?.preventDefault?.();
        if (this.actor.type !== "npc") return;

        const canModify = this.actor?.canUserModify?.(game.user, "update");
        if (this.isEditable || canModify) {
            ui.notifications.info("This NPC is already editable.");
            return this.actor;
        }

        const copyData = this._buildNpcWorldCopyData();
        const created = await Actor.create(copyData);
        if (!created) {
            ui.notifications.warn("Failed to create editable NPC copy.");
            return null;
        }

        ui.notifications.info(`${created.name}: editable copy created in Actor Directory.`);
        created.sheet?.render(true);
        return created;
    }

    async _onNpcPresetApply(ev) {
        ev.preventDefault();
        if (this.actor.type !== "npc") return;
        if (!this._ensureNpcEditable()) {
            if (this.actor.pack) await this._onNpcImportWorld();
            return;
        }
        const root = this.element?.[0];
        const presetId = String(root?.querySelector('[name="npcPreset"]')?.value ?? "").trim();
        if (!presetId) {
            ui.notifications.warn("Choose an NPC archetype first.");
            return;
        }

        const preset = await applyNpcPreset(this.actor, presetId, { replaceActions: true });
        if (!preset) {
            ui.notifications.warn("Failed to apply NPC preset.");
            return;
        }
        ui.notifications.info(`${this.actor.name}: preset applied (${preset.name}).`);
        this.render(false);
    }

    async _onNpcActionAdd(ev) {
        ev.preventDefault();
        if (this.actor.type !== "npc") return;
        if (!this._ensureNpcEditable()) {
            if (this.actor.pack) await this._onNpcImportWorld();
            return;
        }
        const requestedKind = String(ev.currentTarget?.dataset?.actionKind ?? "attack").trim().toLowerCase();
        const kind = ["attack", "spell", "test"].includes(requestedKind) ? requestedKind : "attack";
        const actions = this._collectNpcQuickActionsFromSheet();
        actions.push(this._createNpcQuickAction(kind));
        await this._setNpcQuickActions(actions);
        ui.notifications.info(`${this.actor.name}: added ${kind} one-line action.`);
        this.render(false);
    }

    async _onNpcActionDelete(ev) {
        ev.preventDefault();
        if (this.actor.type !== "npc") return;
        if (!this._ensureNpcEditable()) return;
        const actions = this._collectNpcQuickActionsFromSheet();
        const index = this._resolveNpcActionIndex(ev.currentTarget, actions);
        if (index < 0 || index >= actions.length) return;
        actions.splice(index, 1);
        await this._setNpcQuickActions(actions);
        this.render(false);
    }

    async _onNpcActionDuplicate(ev) {
        ev.preventDefault();
        if (this.actor.type !== "npc") return;
        if (!this._ensureNpcEditable()) return;
        const actions = this._collectNpcQuickActionsFromSheet();
        const index = this._resolveNpcActionIndex(ev.currentTarget, actions);
        if (index < 0 || index >= actions.length) return;
        const original = actions[index];
        if (!original) return;

        const copyName = String(original.name ?? "New Action").trim();
        actions.splice(index + 1, 0, normalizeNpcQuickAction({
            ...original,
            id: undefined,
            name: copyName ? `${copyName} (Copy)` : "New Action (Copy)"
        }));
        await this._setNpcQuickActions(actions);
        this.render(false);
    }

    async _onNpcActionMove(ev) {
        ev.preventDefault();
        if (this.actor.type !== "npc") return;
        if (!this._ensureNpcEditable()) return;
        const direction = String(ev.currentTarget?.dataset?.direction ?? "").trim().toLowerCase();
        const delta = direction === "up" ? -1 : (direction === "down" ? 1 : 0);
        if (!delta) return;

        const actions = this._collectNpcQuickActionsFromSheet();
        const index = this._resolveNpcActionIndex(ev.currentTarget, actions);
        if (index < 0 || index >= actions.length) return;
        const targetIndex = index + delta;
        if (targetIndex < 0 || targetIndex >= actions.length) return;
        [actions[index], actions[targetIndex]] = [actions[targetIndex], actions[index]];
        await this._setNpcQuickActions(actions);
        this.render(false);
    }

    async _onNpcActionFieldChange(ev) {
        if (this.actor.type !== "npc") return;
        if (!this._ensureNpcEditable()) return;
        const actions = this._collectNpcQuickActionsFromSheet();
        await this._setNpcQuickActions(actions);
    }

    async _onNpcActionRoll(ev) {
        ev.preventDefault();
        if (this.actor.type !== "npc") return;
        const actions = this._collectNpcQuickActionsFromSheet();
        const index = this._resolveNpcActionIndex(ev.currentTarget, actions);
        const action = actions[index];
        if (!action) {
            ui.notifications.warn("NPC action could not be resolved. Try reopening the sheet.");
            return;
        }

        const kind = String(action.kind ?? "attack");
        const isWeaponAttack = kind === "attack";
        const isSpell = kind === "spell";
        const isMagic = Boolean(action.isMagic || isSpell);
        const attackMode = String(action.traits ?? "").toLowerCase().includes("melee") ? "melee" : "ranged";
        const flavour = `${action.name} (${this.actor.name})`;
        const pool = Math.max(1, Math.trunc(Number(action.pool) || 0));
        const dn = Math.max(2, Math.min(6, Math.trunc(Number(action.dn) || 4)));
        const complexity = Math.max(1, Math.trunc(Number(action.complexity) || 1));

        await rollDice({
            pool,
            dn,
            complexity,
            flavor: flavour,
            damage: String(action.damage ?? "").trim(),
            isWeaponAttack,
            actorId: this.actor.id,
            allowPostRollFocus: false,
            prompt: false,
            attackMeta: isWeaponAttack
                ? {
                    mode: attackMode,
                    hasTarget: Boolean(game.user?.targets?.size),
                    attackerRating: attackMode === "melee"
                        ? Math.max(0, Math.trunc(Number(this.actor.system?.derived?.melee?.value) || 0))
                        : Math.max(0, Math.trunc(Number(this.actor.system?.derived?.accuracy?.value) || 0)),
                    defenceRating: 0,
                    ladderDelta: 0,
                    defencePenalty: 0,
                    weaponTraits: String(action.traits ?? "")
                }
                : null,
            rollContext: {
                sourceType: isSpell ? "spell" : "skill",
                sourceName: action.name,
                skillName: isSpell ? "Magic" : action.name,
                attribute: isSpell ? "mind" : "body",
                attackMode: isWeaponAttack ? attackMode : "",
                isMagic,
                isSpell
            }
        });
    }

    async _onNpcActionAutofill(ev) {
        ev.preventDefault();
        if (this.actor.type !== "npc") return;
        if (!this._ensureNpcEditable()) {
            if (this.actor.pack) await this._onNpcImportWorld();
            return;
        }
        const generated = this._buildNpcSuggestedQuickActions();
        if (!generated.length) {
            ui.notifications.warn("No usable loadout found. Add a weapon/spell or use Add Attack/Test/Spell.");
            return;
        }
        await this._setNpcQuickActions(generated);
        ui.notifications.info(`${this.actor.name}: one-line actions generated from loadout.`);
        this.render(false);
    }

    async _onNpcResetDefeated(ev) {
        ev.preventDefault();
        if (this.actor.type !== "npc") return;
        if (!this._ensureNpcEditable()) return;
        const maxToughness = Math.max(1, Math.trunc(Number(this.actor.system?.derived?.toughness?.max) || 1));
        await this.actor.update({
            "system.npc.defeated": false,
            "system.derived.toughness.value": maxToughness,
            "system.derived.toughness.damage": 0
        });
        ui.notifications.info(`${this.actor.name}: marked as active.`);
        this.render(false);
    }

    _getNpcQuickActions() {
        const systemActions = this.actor.system?.npc?.quickActions;
        if (Array.isArray(systemActions) && systemActions.length) {
            return systemActions.map(entry => normalizeNpcQuickAction(entry));
        }
        const flaggedActions = this.actor.getFlag?.("laundry-rpg", "npcQuickActions");
        if (Array.isArray(flaggedActions) && flaggedActions.length) {
            return flaggedActions.map(entry => normalizeNpcQuickAction(entry));
        }
        return this._buildNpcSuggestedQuickActions();
    }

    _ensureNpcEditable() {
        const canModify = Boolean(
            this.isEditable
            || this.actor?.isOwner
            || this.actor?.canUserModify?.(game.user, "update")
        );
        if (canModify) return true;
        ui.notifications.warn("This NPC is read-only. Import or duplicate it into the world before editing one-line actions.");
        return false;
    }

    _buildNpcWorldCopyData() {
        const source = foundry.utils.deepClone(this.actor.toObject());
        delete source._id;
        source.folder = null;
        source.pack = null;
        source.sort = 0;
        source.ownership = { default: 0 };
        if (game.user?.id) source.ownership[game.user.id] = 3;

        if (Array.isArray(source.items)) {
            for (const item of source.items) {
                if (item && typeof item === "object") delete item._id;
            }
        }
        if (Array.isArray(source.effects)) {
            for (const effect of source.effects) {
                if (effect && typeof effect === "object") delete effect._id;
            }
        }
        if (source.prototypeToken && typeof source.prototypeToken === "object") {
            delete source.prototypeToken._id;
        }
        return source;
    }

    _createNpcQuickAction(kind = "attack") {
        const actionKind = ["attack", "spell", "test"].includes(String(kind)) ? String(kind) : "attack";
        const body = Math.max(1, Math.trunc(Number(this.actor.system?.attributes?.body?.value) || 1));
        const mind = Math.max(1, Math.trunc(Number(this.actor.system?.attributes?.mind?.value) || 1));
        const melee = Math.max(1, Math.trunc(Number(this.actor.system?.derived?.melee?.value) || body));
        const accuracy = Math.max(1, Math.trunc(Number(this.actor.system?.derived?.accuracy?.value) || body));
        const basePool = actionKind === "spell"
            ? Math.max(mind, accuracy)
            : (actionKind === "test" ? Math.max(1, Math.min(melee, accuracy)) : Math.max(melee, accuracy));

        return normalizeNpcQuickAction({
            name: actionKind === "spell"
                ? "New Spell Action"
                : (actionKind === "test" ? "New Test Action" : "New Attack Action"),
            kind: actionKind,
            pool: basePool,
            dn: 4,
            complexity: 1,
            damage: actionKind === "test" ? "" : "1d6",
            traits: "",
            isMagic: actionKind === "spell"
        });
    }

    _buildNpcSuggestedQuickActions() {
        if (this.actor?.type !== "npc") return [];
        const melee = Math.max(1, Math.trunc(Number(this.actor.system?.derived?.melee?.value) || this.actor.system?.attributes?.body?.value || 1));
        const accuracy = Math.max(1, Math.trunc(Number(this.actor.system?.derived?.accuracy?.value) || this.actor.system?.attributes?.body?.value || 1));
        const mind = Math.max(1, Math.trunc(Number(this.actor.system?.attributes?.mind?.value) || 1));
        const out = [];

        const weapons = this.actor.items
            .filter(item => item.type === "weapon")
            .sort((a, b) => a.name.localeCompare(b.name));
        const equippedWeapons = weapons.filter(item => item.system?.equipped === true);
        const preferredWeapons = (equippedWeapons.length ? equippedWeapons : weapons).slice(0, 4);

        for (const weapon of preferredWeapons) {
            const skillText = String(weapon.system?.skill ?? "").trim().toLowerCase();
            const isMelee = skillText.includes("close") || skillText.includes("melee");
            const pool = isMelee ? melee : accuracy;
            out.push(normalizeNpcQuickAction({
                name: String(weapon.name ?? "Weapon Attack").trim() || "Weapon Attack",
                kind: "attack",
                pool,
                dn: 4,
                complexity: 1,
                damage: String(weapon.system?.damage ?? "1d6").trim(),
                traits: String(weapon.system?.traits ?? "").trim(),
                isMagic: false
            }));
        }

        const spells = this.actor.items
            .filter(item => item.type === "spell")
            .sort((a, b) => a.name.localeCompare(b.name))
            .slice(0, 3);
        for (const spell of spells) {
            out.push(normalizeNpcQuickAction({
                name: String(spell.name ?? "Spell").trim() || "Spell",
                kind: "spell",
                pool: Math.max(mind, accuracy),
                dn: Math.max(2, Math.min(6, Math.trunc(Number(spell.system?.dn) || 4))),
                complexity: Math.max(1, Math.trunc(Number(spell.system?.complexity ?? spell.system?.level) || 1)),
                damage: "",
                traits: String(spell.system?.target ?? "").trim(),
                isMagic: true
            }));
        }

        if (!out.length) {
            out.push(this._createNpcQuickAction("attack"));
            out.push(this._createNpcQuickAction("test"));
        }

        const deduped = [];
        const seen = new Set();
        for (const action of out) {
            const key = `${String(action.kind ?? "").toLowerCase()}::${String(action.name ?? "").trim().toLowerCase()}`;
            if (seen.has(key)) continue;
            seen.add(key);
            deduped.push(action);
        }
        return deduped;
    }

    _resolveNpcActionIndex(node, actions = []) {
        const actionId = String(node?.dataset?.actionId ?? "").trim();
        if (actionId) {
            const idIndex = actions.findIndex(entry => String(entry?.id ?? "").trim() === actionId);
            if (idIndex >= 0) return idIndex;
        }
        const parsed = Math.trunc(Number(node?.dataset?.actionIndex));
        return Number.isInteger(parsed) ? parsed : -1;
    }

    _collectNpcQuickActionsFromSheet() {
        const fallbackActions = this._getNpcQuickActions();
        const root = this.element?.[0];
        if (!root) return fallbackActions;

        const rows = Array.from(root.querySelectorAll(".npc-action-row"));
        if (!rows.length) return fallbackActions;

        const collectText = (row, key, fallback = "") => {
            const field = row.querySelector(`.npc-action-field[data-action-key="${key}"]`);
            return field ? String(field.value ?? "").trim() : String(fallback ?? "").trim();
        };
        const collectNumber = (row, key, fallback = 0) => {
            const field = row.querySelector(`.npc-action-field[data-action-key="${key}"]`);
            const value = Number(field?.value ?? fallback);
            return Number.isFinite(value) ? Math.trunc(value) : Math.trunc(Number(fallback) || 0);
        };
        const collectBoolean = (row, key, fallback = false) => {
            const field = row.querySelector(`.npc-action-field[data-action-key="${key}"]`);
            return field instanceof HTMLInputElement ? Boolean(field.checked) : Boolean(fallback);
        };

        return rows.map((row, rowOrder) => {
            const index = Math.trunc(Number(row?.dataset?.actionIndex) || -1);
            const actionId = String(row?.dataset?.actionId ?? "").trim();
            const currentById = actionId
                ? fallbackActions.find(entry => String(entry?.id ?? "").trim() === actionId)
                : null;
            const current = currentById
                ?? (index >= 0 && index < fallbackActions.length
                    ? fallbackActions[index]
                    : (fallbackActions[rowOrder] ?? {}));
            return normalizeNpcQuickAction({
                id: actionId || current?.id,
                name: collectText(row, "name", current?.name ?? "New Action"),
                kind: collectText(row, "kind", current?.kind ?? "attack"),
                pool: collectNumber(row, "pool", current?.pool ?? 0),
                dn: collectNumber(row, "dn", current?.dn ?? 4),
                complexity: collectNumber(row, "complexity", current?.complexity ?? 1),
                damage: collectText(row, "damage", current?.damage ?? ""),
                traits: collectText(row, "traits", current?.traits ?? ""),
                isMagic: collectBoolean(row, "isMagic", current?.isMagic ?? false)
            });
        });
    }

    async _setNpcQuickActions(actions = []) {
        const normalized = actions.map(entry => normalizeNpcQuickAction(entry));
        const syncLocalSource = () => {
            try {
                this.actor.updateSource?.({
                    "system.npc.quickActions": normalized,
                    "flags.laundry-rpg.npcQuickActions": normalized
                });
            } catch (error) {
                console.warn("Laundry RPG | Failed to sync local NPC quick action source.", error);
            }
        };
        try {
            await this.actor.update({
                "system.npc.quickActions": normalized,
                "flags.laundry-rpg.npcQuickActions": normalized
            });
            syncLocalSource();
        } catch (error) {
            console.error("Laundry RPG | Failed to write system.npc.quickActions, falling back to flags.", error);
            try {
                await this.actor.update({
                    "flags.laundry-rpg.npcQuickActions": normalized
                });
                syncLocalSource();
                ui.notifications.warn("Saved NPC one-line actions to fallback storage (flags).");
            } catch (fallbackError) {
                console.error("Laundry RPG | Failed to persist NPC quick actions to flags fallback.", fallbackError);
                ui.notifications.error("Failed to save NPC one-line actions. Duplicate/import this NPC into world and try again.");
            }
        }
    }

    async _onBioAutofill(ev) {
        ev.preventDefault();
        const profile = this.actor.system?.details?.profile ?? {};
        const actorName = this.actor.name ?? "Unnamed Agent";
        const assignment = String(this.actor.system?.details?.assignment ?? "").trim();
        const lines = [];

        const codename = String(profile.codename ?? "").trim();
        lines.push(codename ? `${actorName} (${codename}) serves with The Laundry.` : `${actorName} serves with The Laundry.`);

        const background = String(profile.background ?? "").trim();
        const coverIdentity = String(profile.coverIdentity ?? "").trim();
        const shortGoal = String(profile.shortGoal ?? "").trim();
        const longGoal = String(profile.longGoal ?? "").trim();
        const notableIncident = String(profile.notableIncident ?? "").trim();
        const notes = String(profile.personalNotes ?? "").trim();

        if (assignment) lines.push(`Current assignment: ${assignment}.`);
        if (background) lines.push(`Background: ${background}.`);
        if (coverIdentity) lines.push(`Cover identity: ${coverIdentity}.`);
        if (shortGoal) lines.push(`Short-term objective: ${shortGoal}.`);
        if (longGoal) lines.push(`Long-term objective: ${longGoal}.`);
        if (notableIncident) lines.push(`Notable incident: ${notableIncident}.`);
        if (notes) lines.push(`Additional notes: ${notes}.`);

        const html = lines
            .map(line => `<p>${foundry.utils.escapeHTML(line)}</p>`)
            .join("");
        await this.actor.update({ "system.biography": html });
    }

    async _onKpiAdd(ev) {
        ev.preventDefault();
        if (!(this.actor.isOwner || game.user?.isGM)) return;
        const requested = String(ev.currentTarget?.dataset?.kpiHorizon ?? "short");
        const horizon = KPI_HORIZONS.some(option => option.key === requested)
            ? requested
            : "short";
        const kpis = this._getActorKpis();
        kpis.push(createNewKpi(horizon));
        await this.actor.update({ "system.kpi": kpis });
    }

    async _onKpiDelete(ev) {
        ev.preventDefault();
        if (!game.user?.isGM) {
            ui.notifications.warn("Only the GM can delete KPI entries.");
            return;
        }
        const index = Number(ev.currentTarget.dataset.kpiIndex);
        if (!Number.isInteger(index) || index < 0) return;
        const kpis = this._getActorKpis();
        if (index >= kpis.length) return;
        kpis.splice(index, 1);
        await this.actor.update({ "system.kpi": kpis });
    }

    async _onKpiClose(ev) {
        ev.preventDefault();
        if (!game.user?.isGM) {
            ui.notifications.warn("Only the GM can close KPIs.");
            return;
        }

        const index = Number(ev.currentTarget?.dataset?.kpiIndex);
        const requested = String(ev.currentTarget?.dataset?.kpiResult ?? "completed").trim().toLowerCase();
        if (!Number.isInteger(index) || index < 0) return;
        const result = requested === "failed" ? "failed" : "completed";

        const closure = closeKpiAtIndex(this._getActorKpis(), {
            index,
            status: result,
            userId: game.user.id,
            closedAt: Date.now()
        });
        if (!closure.changed) return;

        const rewardXp = Math.max(0, Math.trunc(Number(closure.reward?.xp) || 0));
        const actorXpTotal = Math.max(0, Math.trunc(Number(this.actor.system?.details?.xp?.value) || 0));
        const actorXpUnspent = Math.max(0, Math.trunc(Number(this.actor.system?.details?.xp?.unspent) || 0));
        const update = {
            "system.kpi": closure.entries,
            "system.details.xp.value": actorXpTotal + rewardXp,
            "system.details.xp.unspent": actorXpUnspent + rewardXp
        };
        await this.actor.update(update);
        await this._applyKpiLuckReward(String(closure.reward?.luck ?? "none"));

        const statusLabel = result === "completed" ? "completed" : "failed";
        const xpLabel = rewardXp > 0 ? ` (+${rewardXp} XP)` : "";
        ui.notifications.info(`${this.actor.name}: KPI ${statusLabel}${xpLabel}.`);
    }

    _onKpiArchiveToggle(ev) {
        ev.preventDefault();
        const horizon = String(ev.currentTarget?.dataset?.kpiHorizon ?? "").trim();
        if (!horizon) return;
        const show = String(ev.currentTarget?.dataset?.show ?? "1").trim() === "1";
        this._setKpiArchiveVisible(horizon, show);
        this.render(false);
    }

    async _onKpiFieldChange(ev) {
        const index = Number(ev.currentTarget.dataset.kpiIndex);
        const key = String(ev.currentTarget.dataset.kpiKey ?? "");
        if (!(this.actor.isOwner || game.user?.isGM)) return;
        if (!Number.isInteger(index) || index < 0) return;
        const kpis = this._getActorKpis();
        if (!kpis[index]) return;
        if (!game.user?.isGM && kpis[index].status !== "open") return;
        if (key === "status" && !game.user?.isGM) {
            ui.notifications.warn("Only the GM can close KPIs.");
            ev.currentTarget.value = String(kpis[index].status ?? "open");
            return;
        }

        switch (key) {
            case "text":
                kpis[index].text = String(ev.currentTarget.value ?? "");
                break;
            case "owner":
                kpis[index].owner = String(ev.currentTarget.value ?? "");
                break;
            case "horizon": {
                const value = String(ev.currentTarget.value ?? "");
                if (KPI_HORIZONS.some(option => option.key === value)) {
                    kpis[index].horizon = value;
                }
                break;
            }
            case "priority": {
                const value = String(ev.currentTarget.value ?? "");
                if (KPI_PRIORITIES.some(option => option.key === value)) {
                    kpis[index].priority = value;
                }
                break;
            }
            case "status": {
                const value = String(ev.currentTarget.value ?? "");
                if (KPI_STATUSES.some(option => option.key === value)) {
                    kpis[index].status = value;
                    if (value === "completed") kpis[index].progress = 100;
                    if (value === "open") {
                        kpis[index].closedAt = 0;
                        kpis[index].closedBy = "";
                        kpis[index].rewardedXp = 0;
                        kpis[index].rewardLuckMode = "none";
                    }
                }
                break;
            }
            case "progress": {
                const value = Number(ev.currentTarget.value ?? 0);
                const progress = Number.isFinite(value)
                    ? Math.max(0, Math.min(100, Math.trunc(value)))
                    : 0;
                kpis[index].progress = progress;
                if (progress >= 100 && kpis[index].status === "open") {
                    kpis[index].status = "completed";
                }
                break;
            }
            case "dueDate": {
                const value = String(ev.currentTarget.value ?? "").trim();
                kpis[index].dueDate = /^\d{4}-\d{2}-\d{2}$/.test(value) ? value : "";
                break;
            }
            default:
                return;
        }

        await this.actor.update({ "system.kpi": kpis });
    }

    _getKpiArchiveMap() {
        if (!this._kpiArchiveVisibility || typeof this._kpiArchiveVisibility !== "object") {
            this._kpiArchiveVisibility = {};
        }
        return this._kpiArchiveVisibility;
    }

    _isKpiArchiveVisible(horizon = "") {
        const key = String(horizon ?? "").trim();
        if (!key) return false;
        return Boolean(this._getKpiArchiveMap()[key]);
    }

    _setKpiArchiveVisible(horizon = "", visible = false) {
        const key = String(horizon ?? "").trim();
        if (!key) return;
        this._getKpiArchiveMap()[key] = Boolean(visible);
    }

    _getActorKpis() {
        return normalizeKpiEntries(this.actor.system?.kpi).map(entry => ({
            id: entry.id,
            text: entry.text,
            status: entry.status,
            horizon: entry.horizon,
            priority: entry.priority,
            dueDate: entry.dueDate,
            progress: entry.progress,
            owner: entry.owner,
            closedAt: entry.closedAt,
            closedBy: entry.closedBy,
            rewardedXp: entry.rewardedXp,
            rewardLuckMode: entry.rewardLuckMode
        }));
    }

    async _applyKpiLuckReward(mode = "none") {
        if (!game.user?.isGM) return;
        const rewardMode = String(mode ?? "none").trim().toLowerCase();
        if (rewardMode === "none") return;

        const currentLuck = Math.max(0, Math.trunc(Number(game.settings.get("laundry-rpg", "teamLuck")) || 0));
        const maxLuck = Math.max(0, Math.trunc(Number(game.settings.get("laundry-rpg", "teamLuckMax")) || 0));
        if (rewardMode === "refill") {
            await game.settings.set("laundry-rpg", "teamLuck", maxLuck);
            return;
        }
        if (rewardMode === "plus1") {
            const next = Math.max(0, Math.min(maxLuck, currentLuck + 1));
            await game.settings.set("laundry-rpg", "teamLuck", next);
        }
    }

    async _onKpiShopBuy(ev) {
        ev.preventDefault();
        if (this.actor.type !== "character") return;
        if (!(this.actor.isOwner || game.user?.isGM)) {
            ui.notifications.warn("Only the GM or actor owner can purchase upgrades.");
            return;
        }

        const root = this.element?.[0];
        if (!root) return;
        const kind = String(ev.currentTarget?.dataset?.shopKind ?? "").trim().toLowerCase();
        if (kind === "skill-training" || kind === "skill-focus") {
            const skillName = String(root.querySelector('[name="kpiShopSkill"]')?.value ?? "").trim();
            const stat = kind === "skill-focus" ? "focus" : "training";
            await this._buySkillUpgrade(skillName, stat);
            return;
        }
        if (kind === "attribute") {
            const attribute = String(root.querySelector('[name="kpiShopAttribute"]')?.value ?? "").trim().toLowerCase();
            await this._buyAttributeUpgrade(attribute);
        }
    }

    async _buySkillUpgrade(skillName, stat = "training") {
        const safeName = String(skillName ?? "").trim();
        if (!safeName) {
            ui.notifications.warn("Select a skill first.");
            return;
        }
        const key = stat === "focus" ? "focus" : "training";
        const skill = this.actor.items.find(item => item.type === "skill" && item.name === safeName);
        if (!skill) {
            ui.notifications.warn(`Skill not found on actor: ${safeName}.`);
            return;
        }
        const current = Math.max(0, Math.trunc(Number(skill.system?.[key]) || 0));
        if (current >= 4) {
            ui.notifications.warn(`${safeName} ${key} is already at maximum rank.`);
            return;
        }
        const next = current + 1;
        const cost = _skillUpgradeCost(next);
        if (!Number.isFinite(cost) || cost <= 0) return;

        const unspent = Math.max(0, Math.trunc(Number(this.actor.system?.details?.xp?.unspent) || 0));
        if (unspent < cost) {
            ui.notifications.warn(`Not enough XP. Need ${cost}, have ${unspent}.`);
            return;
        }

        await skill.update({ [`system.${key}`]: next });
        await this.actor.update({ "system.details.xp.unspent": unspent - cost });
        ui.notifications.info(`${this.actor.name}: ${safeName} ${key} ${current} -> ${next} (cost ${cost} XP).`);
    }

    async _buyAttributeUpgrade(attribute = "") {
        const key = ["body", "mind", "spirit"].includes(String(attribute ?? "").toLowerCase())
            ? String(attribute).toLowerCase()
            : "";
        if (!key) {
            ui.notifications.warn("Select an attribute first.");
            return;
        }

        const current = Math.max(1, Math.trunc(Number(this.actor.system?.attributes?.[key]?.value) || 1));
        if (current >= 4) {
            ui.notifications.warn(`${key.toUpperCase()} is already at maximum rank.`);
            return;
        }
        const next = current + 1;
        const cost = _attributeUpgradeCost(current);
        if (cost <= 0) return;

        const unspent = Math.max(0, Math.trunc(Number(this.actor.system?.details?.xp?.unspent) || 0));
        if (unspent < cost) {
            ui.notifications.warn(`Not enough XP. Need ${cost}, have ${unspent}.`);
            return;
        }

        await this.actor.update({
            [`system.attributes.${key}.value`]: next,
            "system.details.xp.unspent": unspent - cost
        });
        ui.notifications.info(`${this.actor.name}: ${key.toUpperCase()} ${current} -> ${next} (cost ${cost} XP).`);
    }

    async _onKpiShopBuyTalent(ev) {
        ev.preventDefault();
        if (this.actor.type !== "character") return;
        if (!(this.actor.isOwner || game.user?.isGM)) {
            ui.notifications.warn("Only the GM or actor owner can purchase upgrades.");
            return;
        }

        const TALENT_COST = 4;
        const unspent = Math.max(0, Math.trunc(Number(this.actor.system?.details?.xp?.unspent) || 0));
        if (unspent < TALENT_COST) {
            ui.notifications.warn(`Not enough XP. Need ${TALENT_COST}, have ${unspent}.`);
            return;
        }

        const pack = game.packs.get("laundry-rpg.talents") ?? null;
        if (!pack) {
            ui.notifications.warn("Talents compendium is unavailable.");
            return;
        }

        const talent = await this._pickTalentFromCompendium(pack);
        if (!talent) return;

        const talentName = String(talent.name ?? "").trim();
        const duplicate = this.actor.items.some(item =>
            item.type === "talent" && String(item.name ?? "").trim().toLowerCase() === talentName.toLowerCase()
        );
        if (duplicate) {
            ui.notifications.warn(`${this.actor.name} already has "${talentName}".`);
            return;
        }

        await this.actor.createEmbeddedDocuments("Item", [talent.toObject()]);
        await this.actor.update({ "system.details.xp.unspent": unspent - TALENT_COST });
        ui.notifications.info(`${this.actor.name}: purchased talent "${talentName}" (${TALENT_COST} XP).`);
    }

    async _pickTalentFromCompendium(pack) {
        const docs = await pack.getDocuments();
        const talents = docs
            .filter(doc => String(doc.type ?? "").trim().toLowerCase() === "talent")
            .sort((a, b) => String(a.name ?? "").localeCompare(String(b.name ?? "")));
        if (!talents.length) {
            ui.notifications.warn("No talents found in compendium.");
            return null;
        }

        const optionsHtml = talents
            .map(doc => `<option value="${foundry.utils.escapeHTML(doc.id)}">${foundry.utils.escapeHTML(doc.name ?? "Talent")}</option>`)
            .join("");
        const content = `
            <form class="laundry-talent-shop">
                <div class="form-group">
                    <label>Select Talent</label>
                    <select name="talentId">${optionsHtml}</select>
                </div>
            </form>
        `;

        const selectedId = await new Promise(resolve => {
            new Dialog({
                title: "Upgrade Shop: Buy Talent (4 XP)",
                content,
                buttons: {
                    buy: {
                        label: "Buy",
                        callback: html => resolve(String(html.find('[name=\"talentId\"]').val() ?? "").trim())
                    },
                    cancel: {
                        label: "Cancel",
                        callback: () => resolve("")
                    }
                },
                default: "buy",
                close: () => resolve("")
            }).render(true);
        });

        if (!selectedId) return null;
        return talents.find(doc => doc.id === selectedId) ?? null;
    }

    // ─── Drag & Drop: Assignment ───────────────────────────────────────────────

    /** @override */
    async _onDropItem(event, data) {
        if (!this.actor.isOwner) return false;

        const item     = await Item.implementation.fromDropData(data);
        const itemData = item.toObject();

        if (itemData.type === "assignment") {
            return this._applyAssignment(itemData);
        }

        if (itemData.type === "talent") {
            const prereq = evaluateTalentPrerequisites(this.actor, itemData);
            if (!prereq.enforceMet) {
                const details = describeTalentPrerequisiteResult(prereq);
                if (!game.user?.isGM) {
                    ui.notifications.warn(game.i18n.format("LAUNDRY.TalentPrereqBlocked", {
                        talent: itemData.name
                    }));
                    ui.notifications.warn(details);
                    return false;
                }

                const override = await Dialog.confirm({
                    title: game.i18n.localize("LAUNDRY.TalentPrereqOverrideTitle"),
                    content: `<p>${game.i18n.format("LAUNDRY.TalentPrereqOverrideBody", {
                        talent: itemData.name
                    })}</p><p>${details}</p>`,
                    classes: ["laundry-rpg", "laundry-dialog"]
                });
                if (!override) return false;
            }
        }

        return super._onDropItem(event, data);
    }

    async _applyAssignment(assignmentData) {
        await applyAssignmentToActor(this.actor, assignmentData, {
            chosenTalents: [],
            skillAllocations: {},
            profileDraft: this.actor.system?.details?.profile ?? {},
            biographyDraft: String(this.actor.system?.biography ?? "").trim(),
            applyBiography: false,
            overwriteBiography: false
        });
    }
}

function _skillUpgradeCost(targetRank) {
    const rank = Math.max(1, Math.trunc(Number(targetRank) || 1));
    if (rank <= 1) return 1;
    if (rank === 2) return 2;
    if (rank === 3) return 3;
    if (rank === 4) return 4;
    return 0;
}

function _attributeUpgradeCost(currentRank) {
    const rank = Math.max(1, Math.trunc(Number(currentRank) || 1));
    if (rank === 1) return 3;
    if (rank === 2) return 5;
    if (rank === 3) return 10;
    return 0;
}

export class LaundryNpcSheet extends LaundryActorSheet {

    /** @override */
    static get defaultOptions() {
        return foundry.utils.mergeObject(super.defaultOptions, {
            template: "systems/laundry-rpg/templates/actor/npc-sheet.html",
            width: 620,
            height: 700,
            tabs: [{ navSelector: ".sheet-tabs", contentSelector: ".sheet-body", initial: "npc-actions" }]
        });
    }
}
